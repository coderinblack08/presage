{"version":3,"file":"inMemoryCache.js","sourceRoot":"","sources":["../../../src/cache/inmemory/inMemoryCache.ts"],"names":[],"mappings":"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","sourcesContent":["// Make builtins like Map and Set safe to use with non-extensible objects.\nimport './fixPolyfills';\n\nimport { DocumentNode } from 'graphql';\nimport { dep, wrap } from 'optimism';\n\nimport { ApolloCache } from '../core/cache';\nimport { Cache } from '../core/types/Cache';\nimport { MissingFieldError } from '../core/types/common';\nimport {\n  addTypenameToDocument,\n  StoreObject,\n  Reference,\n  isReference,\n} from '../../utilities';\nimport {\n  ApolloReducerConfig,\n  NormalizedCacheObject,\n} from './types';\nimport { StoreReader } from './readFromStore';\nimport { StoreWriter } from './writeToStore';\nimport { EntityStore, supportsResultCaching } from './entityStore';\nimport { makeVar, forgetCache, recallCache } from './reactiveVars';\nimport {\n  defaultDataIdFromObject,\n  PossibleTypesMap,\n  Policies,\n  TypePolicies,\n} from './policies';\nimport { hasOwn } from './helpers';\n\nexport interface InMemoryCacheConfig extends ApolloReducerConfig {\n  resultCaching?: boolean;\n  possibleTypes?: PossibleTypesMap;\n  typePolicies?: TypePolicies;\n}\n\nconst defaultConfig: InMemoryCacheConfig = {\n  dataIdFromObject: defaultDataIdFromObject,\n  addTypename: true,\n  resultCaching: true,\n  typePolicies: {},\n};\n\nexport class InMemoryCache extends ApolloCache<NormalizedCacheObject> {\n  private data: EntityStore;\n  private optimisticData: EntityStore;\n\n  protected config: InMemoryCacheConfig;\n  private watches = new Set<Cache.WatchOptions>();\n  private addTypename: boolean;\n\n  private typenameDocumentCache = new Map<DocumentNode, DocumentNode>();\n  private storeReader: StoreReader;\n  private storeWriter: StoreWriter;\n\n  // Dynamically imported code can augment existing typePolicies or\n  // possibleTypes by calling cache.policies.addTypePolicies or\n  // cache.policies.addPossibletypes.\n  public readonly policies: Policies;\n\n  public readonly makeVar = makeVar;\n\n  constructor(config: InMemoryCacheConfig = {}) {\n    super();\n    this.config = { ...defaultConfig, ...config };\n    this.addTypename = !!this.config.addTypename;\n\n    this.policies = new Policies({\n      cache: this,\n      dataIdFromObject: this.config.dataIdFromObject,\n      possibleTypes: this.config.possibleTypes,\n      typePolicies: this.config.typePolicies,\n    });\n\n    // Passing { resultCaching: false } in the InMemoryCache constructor options\n    // will completely disable dependency tracking, which will improve memory\n    // usage but worsen the performance of repeated reads.\n    this.data = new EntityStore.Root({\n      policies: this.policies,\n      resultCaching: this.config.resultCaching,\n    });\n\n    // When no optimistic writes are currently active, cache.optimisticData ===\n    // cache.data, so there are no additional layers on top of the actual data.\n    // When an optimistic update happens, this.optimisticData will become a\n    // linked list of OptimisticCacheLayer objects that terminates with the\n    // original this.data cache object.\n    this.optimisticData = this.data;\n\n    this.storeWriter = new StoreWriter(\n      this,\n      this.storeReader = new StoreReader({\n        cache: this,\n        addTypename: this.addTypename,\n      }),\n    );\n  }\n\n  public restore(data: NormalizedCacheObject): this {\n    if (data) this.data.replace(data);\n    return this;\n  }\n\n  public extract(optimistic: boolean = false): NormalizedCacheObject {\n    return (optimistic ? this.optimisticData : this.data).extract();\n  }\n\n  public read<T>(options: Cache.ReadOptions): T | null {\n    const {\n      // Since read returns data or null, without any additional metadata\n      // about whether/where there might have been missing fields, the\n      // default behavior cannot be returnPartialData = true (like it is\n      // for the diff method), since defaulting to true would violate the\n      // integrity of the T in the return type. However, partial data may\n      // be useful in some cases, so returnPartialData:true may be\n      // specified explicitly.\n      returnPartialData = false,\n    } = options;\n    try {\n      return this.storeReader.diffQueryAgainstStore<T>({\n        store: options.optimistic ? this.optimisticData : this.data,\n        query: options.query,\n        variables: options.variables,\n        rootId: options.rootId,\n        config: this.config,\n        returnPartialData,\n      }).result || null;\n    } catch (e) {\n      if (e instanceof MissingFieldError) {\n        // Swallow MissingFieldError and return null, so callers do not\n        // need to worry about catching \"normal\" exceptions resulting from\n        // incomplete cache data. Unexpected errors will be re-thrown. If\n        // you need more information about which fields were missing, use\n        // cache.diff instead, and examine diffResult.missing.\n        return null;\n      }\n      throw e;\n    }\n  }\n\n  public write(options: Cache.WriteOptions): Reference | undefined {\n    try {\n      ++this.txCount;\n      return this.storeWriter.writeToStore({\n        store: this.data,\n        query: options.query,\n        result: options.result,\n        dataId: options.dataId,\n        variables: options.variables,\n      });\n    } finally {\n      if (!--this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  }\n\n  public modify(options: Cache.ModifyOptions): boolean {\n    if (hasOwn.call(options, \"id\") && !options.id) {\n      // To my knowledge, TypeScript does not currently provide a way to\n      // enforce that an optional property?:type must *not* be undefined\n      // when present. That ability would be useful here, because we want\n      // options.id to default to ROOT_QUERY only when no options.id was\n      // provided. If the caller attempts to pass options.id with a\n      // falsy/undefined value (perhaps because cache.identify failed), we\n      // should not assume the goal was to modify the ROOT_QUERY object.\n      // We could throw, but it seems natural to return false to indicate\n      // that nothing was modified.\n      return false;\n    }\n    const store = options.optimistic // Defaults to false.\n      ? this.optimisticData\n      : this.data;\n    try {\n      ++this.txCount;\n      return store.modify(options.id || \"ROOT_QUERY\", options.fields);\n    } finally {\n      if (!--this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  }\n\n  public diff<T>(options: Cache.DiffOptions): Cache.DiffResult<T> {\n    return this.storeReader.diffQueryAgainstStore({\n      store: options.optimistic ? this.optimisticData : this.data,\n      rootId: options.id || \"ROOT_QUERY\",\n      query: options.query,\n      variables: options.variables,\n      returnPartialData: options.returnPartialData,\n      config: this.config,\n    });\n  }\n\n  public watch(watch: Cache.WatchOptions): () => void {\n    if (!this.watches.size) {\n      // In case we previously called forgetCache(this) because\n      // this.watches became empty (see below), reattach this cache to any\n      // reactive variables on which it previously depended. It might seem\n      // paradoxical that we're able to recall something we supposedly\n      // forgot, but the point of calling forgetCache(this) is to silence\n      // useless broadcasts while this.watches is empty, and to allow the\n      // cache to be garbage collected. If, however, we manage to call\n      // recallCache(this) here, this cache object must not have been\n      // garbage collected yet, and should resume receiving updates from\n      // reactive variables, now that it has a watcher to notify.\n      recallCache(this);\n    }\n    this.watches.add(watch);\n    if (watch.immediate) {\n      this.maybeBroadcastWatch(watch);\n    }\n    return () => {\n      // Once we remove the last watch from this.watches, cache.broadcastWatches\n      // no longer does anything, so we preemptively tell the reactive variable\n      // system to exclude this cache from future broadcasts.\n      if (this.watches.delete(watch) && !this.watches.size) {\n        forgetCache(this);\n      }\n      this.watchDep.dirty(watch);\n      // Remove this watch from the LRU cache managed by the\n      // maybeBroadcastWatch OptimisticWrapperFunction, to prevent memory\n      // leaks involving the closure of watch.callback.\n      this.maybeBroadcastWatch.forget(watch);\n    };\n  }\n\n  // Request garbage collection of unreachable normalized entities.\n  public gc() {\n    return this.optimisticData.gc();\n  }\n\n  // Call this method to ensure the given root ID remains in the cache after\n  // garbage collection, along with its transitive child entities. Note that\n  // the cache automatically retains all directly written entities. By default,\n  // the retainment persists after optimistic updates are removed. Pass true\n  // for the optimistic argument if you would prefer for the retainment to be\n  // discarded when the top-most optimistic layer is removed. Returns the\n  // resulting (non-negative) retainment count.\n  public retain(rootId: string, optimistic?: boolean): number {\n    return (optimistic ? this.optimisticData : this.data).retain(rootId);\n  }\n\n  // Call this method to undo the effect of the retain method, above. Once the\n  // retainment count falls to zero, the given ID will no longer be preserved\n  // during garbage collection, though it may still be preserved by other safe\n  // entities that refer to it. Returns the resulting (non-negative) retainment\n  // count, in case that's useful.\n  public release(rootId: string, optimistic?: boolean): number {\n    return (optimistic ? this.optimisticData : this.data).release(rootId);\n  }\n\n  // Returns the canonical ID for a given StoreObject, obeying typePolicies\n  // and keyFields (and dataIdFromObject, if you still use that). At minimum,\n  // the object must contain a __typename and any primary key fields required\n  // to identify entities of that type. If you pass a query result object, be\n  // sure that none of the primary key fields have been renamed by aliasing.\n  // If you pass a Reference object, its __ref ID string will be returned.\n  public identify(object: StoreObject | Reference): string | undefined {\n    return isReference(object) ? object.__ref :\n      this.policies.identify(object)[0];\n  }\n\n  public evict(options: Cache.EvictOptions): boolean {\n    if (!options.id) {\n      if (hasOwn.call(options, \"id\")) {\n        // See comment in modify method about why we return false when\n        // options.id exists but is falsy/undefined.\n        return false;\n      }\n      options = { ...options, id: \"ROOT_QUERY\" };\n    }\n    try {\n      // It's unlikely that the eviction will end up invoking any other\n      // cache update operations while it's running, but {in,de}crementing\n      // this.txCount still seems like a good idea, for uniformity with\n      // the other update methods.\n      ++this.txCount;\n      return this.optimisticData.evict(options);\n    } finally {\n      if (!--this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  }\n\n  public reset(): Promise<void> {\n    this.data.clear();\n    this.optimisticData = this.data;\n    this.broadcastWatches();\n    return Promise.resolve();\n  }\n\n  public removeOptimistic(idToRemove: string) {\n    const newOptimisticData = this.optimisticData.removeLayer(idToRemove);\n    if (newOptimisticData !== this.optimisticData) {\n      this.optimisticData = newOptimisticData;\n      this.broadcastWatches();\n    }\n  }\n\n  private txCount = 0;\n\n  public performTransaction(\n    transaction: (cache: InMemoryCache) => any,\n    optimisticId?: string | null,\n  ) {\n    const perform = (layer?: EntityStore) => {\n      const { data, optimisticData } = this;\n      ++this.txCount;\n      if (layer) {\n        this.data = this.optimisticData = layer;\n      }\n      try {\n        transaction(this);\n      } finally {\n        --this.txCount;\n        this.data = data;\n        this.optimisticData = optimisticData;\n      }\n    };\n\n    let fromOptimisticTransaction = false;\n\n    if (typeof optimisticId === 'string') {\n      // Note that there can be multiple layers with the same optimisticId.\n      // When removeOptimistic(id) is called for that id, all matching layers\n      // will be removed, and the remaining layers will be reapplied.\n      this.optimisticData = this.optimisticData.addLayer(optimisticId, perform);\n      fromOptimisticTransaction = true;\n    } else if (optimisticId === null) {\n      // Ensure both this.data and this.optimisticData refer to the root\n      // (non-optimistic) layer of the cache during the transaction. Note\n      // that this.data could be a Layer if we are currently executing an\n      // optimistic transaction function, but otherwise will always be an\n      // EntityStore.Root instance.\n      perform(this.data);\n    } else {\n      // Otherwise, leave this.data and this.optimisticData unchanged and\n      // run the transaction with broadcast batching.\n      perform();\n    }\n\n    // This broadcast does nothing if this.txCount > 0.\n    this.broadcastWatches(fromOptimisticTransaction);\n  }\n\n  public transformDocument(document: DocumentNode): DocumentNode {\n    if (this.addTypename) {\n      let result = this.typenameDocumentCache.get(document);\n      if (!result) {\n        result = addTypenameToDocument(document);\n        this.typenameDocumentCache.set(document, result);\n        // If someone calls transformDocument and then mistakenly passes the\n        // result back into an API that also calls transformDocument, make sure\n        // we don't keep creating new query documents.\n        this.typenameDocumentCache.set(result, result);\n      }\n      return result;\n    }\n    return document;\n  }\n\n  protected broadcastWatches(fromOptimisticTransaction?: boolean) {\n    if (!this.txCount) {\n      this.watches.forEach(c => this.maybeBroadcastWatch(c, fromOptimisticTransaction));\n    }\n  }\n\n  private maybeBroadcastWatch = wrap((\n    c: Cache.WatchOptions,\n    fromOptimisticTransaction?: boolean,\n  ) => {\n    return this.broadcastWatch.call(this, c, !!fromOptimisticTransaction);\n  }, {\n    makeCacheKey: (c: Cache.WatchOptions) => {\n      // Return a cache key (thus enabling result caching) only if we're\n      // currently using a data store that can track cache dependencies.\n      const store = c.optimistic ? this.optimisticData : this.data;\n      if (supportsResultCaching(store)) {\n        const { optimistic, rootId, variables } = c;\n        return store.makeCacheKey(\n          c.query,\n          // Different watches can have the same query, optimistic\n          // status, rootId, and variables, but if their callbacks are\n          // different, the (identical) result needs to be delivered to\n          // each distinct callback. The easiest way to achieve that\n          // separation is to include c.callback in the cache key for\n          // maybeBroadcastWatch calls. See issue #5733.\n          c.callback,\n          JSON.stringify({ optimistic, rootId, variables }),\n        );\n      }\n    }\n  });\n\n  private watchDep = dep<Cache.WatchOptions>();\n\n  // This method is wrapped by maybeBroadcastWatch, which is called by\n  // broadcastWatches, so that we compute and broadcast results only when\n  // the data that would be broadcast might have changed. It would be\n  // simpler to check for changes after recomputing a result but before\n  // broadcasting it, but this wrapping approach allows us to skip both\n  // the recomputation and the broadcast, in most cases.\n  private broadcastWatch(\n    c: Cache.WatchOptions,\n    fromOptimisticTransaction: boolean,\n  ) {\n    // First, invalidate any other maybeBroadcastWatch wrapper functions\n    // currently depending on this Cache.WatchOptions object (including\n    // the one currently calling broadcastWatch), so they will be included\n    // in the next broadcast, even if the result they receive is the same\n    // as the previous result they received. This is important because we\n    // are about to deliver a different result to c.callback, so any\n    // previous results should have a chance to be redelivered.\n    this.watchDep.dirty(c);\n\n    // Next, re-depend on this.watchDep for just this invocation of\n    // maybeBroadcastWatch (this is a no-op if broadcastWatch was not\n    // called by maybeBroadcastWatch). This allows only the most recent\n    // maybeBroadcastWatch invocation for this watcher to remain cached,\n    // enabling re-broadcast of previous results even if they have not\n    // changed since they were previously delivered.\n    this.watchDep(c);\n\n    const diff = this.diff<any>({\n      query: c.query,\n      variables: c.variables,\n      optimistic: c.optimistic,\n    });\n\n    if (c.optimistic && fromOptimisticTransaction) {\n      diff.fromOptimisticTransaction = true;\n    }\n\n    c.callback(diff);\n  }\n}\n"]}