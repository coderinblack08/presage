{"version":3,"file":"writeToStore.js","sourceRoot":"","sources":["../../../src/cache/inmemory/writeToStore.ts"],"names":[],"mappings":"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","sourcesContent":["import { SelectionSetNode, FieldNode, DocumentNode } from 'graphql';\nimport { invariant, InvariantError } from 'ts-invariant';\nimport { equal } from '@wry/equality';\n\nimport {\n  createFragmentMap,\n  FragmentMap,\n  getFragmentFromSelection,\n  getDefaultValues,\n  getFragmentDefinitions,\n  getOperationDefinition,\n  getTypenameFromResult,\n  makeReference,\n  isField,\n  resultKeyNameFromField,\n  StoreValue,\n  StoreObject,\n  Reference,\n  isReference,\n  shouldInclude,\n  hasDirectives,\n  cloneDeep,\n} from '../../utilities';\n\nimport { NormalizedCache, ReadMergeModifyContext, MergeTree } from './types';\nimport { makeProcessedFieldsMerger, fieldNameFromStoreName, storeValueIsStoreObject } from './helpers';\nimport { StoreReader } from './readFromStore';\nimport { InMemoryCache } from './inMemoryCache';\nimport { EntityStore } from './entityStore';\n\nexport interface WriteContext extends ReadMergeModifyContext {\n  readonly written: {\n    [dataId: string]: SelectionSetNode[];\n  };\n  readonly fragmentMap?: FragmentMap;\n  // General-purpose deep-merge function for use during writes.\n  merge<T>(existing: T, incoming: T): T;\n};\n\ninterface ProcessSelectionSetOptions {\n  dataId?: string,\n  result: Record<string, any>;\n  selectionSet: SelectionSetNode;\n  context: WriteContext;\n  mergeTree: MergeTree;\n}\n\nexport interface WriteToStoreOptions {\n  query: DocumentNode;\n  result: Object;\n  dataId?: string;\n  store: NormalizedCache;\n  variables?: Object;\n}\n\nexport class StoreWriter {\n  constructor(\n    public readonly cache: InMemoryCache,\n    private reader?: StoreReader,\n  ) {}\n\n  /**\n   * Writes the result of a query to the store.\n   *\n   * @param result The result object returned for the query document.\n   *\n   * @param query The query document whose result we are writing to the store.\n   *\n   * @param store The {@link NormalizedCache} used by Apollo for the `data` portion of the store.\n   *\n   * @param variables A map from the name of a variable to its value. These variables can be\n   * referenced by the query document.\n   *\n   * @return A `Reference` to the written object.\n   */\n  public writeToStore({\n    query,\n    result,\n    dataId,\n    store,\n    variables,\n  }: WriteToStoreOptions): Reference | undefined {\n    const operationDefinition = getOperationDefinition(query)!;\n    const merger = makeProcessedFieldsMerger();\n\n    variables = {\n      ...getDefaultValues(operationDefinition),\n      ...variables!,\n    };\n\n    const ref = this.processSelectionSet({\n      result: result || Object.create(null),\n      dataId,\n      selectionSet: operationDefinition.selectionSet,\n      mergeTree: { map: new Map },\n      context: {\n        store,\n        written: Object.create(null),\n        merge<T>(existing: T, incoming: T) {\n          return merger.merge(existing, incoming) as T;\n        },\n        variables,\n        varString: JSON.stringify(variables),\n        fragmentMap: createFragmentMap(getFragmentDefinitions(query)),\n      },\n    });\n\n    if (!isReference(ref)) {\n      throw new InvariantError(`Could not identify object ${JSON.stringify(result)}`);\n    }\n\n    // Any IDs written explicitly to the cache will be retained as\n    // reachable root IDs for garbage collection purposes. Although this\n    // logic includes root IDs like ROOT_QUERY and ROOT_MUTATION, their\n    // retainment counts are effectively ignored because cache.gc() always\n    // includes them in its root ID set.\n    store.retain(ref.__ref);\n\n    return ref;\n  }\n\n  private processSelectionSet({\n    dataId,\n    result,\n    selectionSet,\n    context,\n    // This object allows processSelectionSet to report useful information\n    // to its callers without explicitly returning that information.\n    mergeTree,\n  }: ProcessSelectionSetOptions): StoreObject | Reference {\n    const { policies } = this.cache;\n\n    // Identify the result object, even if dataId was already provided,\n    // since we always need keyObject below.\n    const [id, keyObject] = policies.identify(\n      result, selectionSet, context.fragmentMap);\n\n    // If dataId was not provided, fall back to the id just generated by\n    // policies.identify.\n    dataId = dataId || id;\n\n    if (\"string\" === typeof dataId) {\n      // Avoid processing the same entity object using the same selection\n      // set more than once. We use an array instead of a Set since most\n      // entity IDs will be written using only one selection set, so the\n      // size of this array is likely to be very small, meaning indexOf is\n      // likely to be faster than Set.prototype.has.\n      const sets = context.written[dataId] || (context.written[dataId] = []);\n      const ref = makeReference(dataId);\n      if (sets.indexOf(selectionSet) >= 0) return ref;\n      sets.push(selectionSet);\n\n      // If we're about to write a result object into the store, but we\n      // happen to know that the exact same (===) result object would be\n      // returned if we were to reread the result with the same inputs,\n      // then we can skip the rest of the processSelectionSet work for\n      // this object, and immediately return a Reference to it.\n      if (this.reader && this.reader.isFresh(\n        result,\n        ref,\n        selectionSet,\n        context,\n      )) {\n        return ref;\n      }\n    }\n\n    // This variable will be repeatedly updated using context.merge to\n    // accumulate all fields that need to be written into the store.\n    let incomingFields: StoreObject = Object.create(null);\n\n    // Write any key fields that were used during identification, even if\n    // they were not mentioned in the original query.\n    if (keyObject) {\n      incomingFields = context.merge(incomingFields, keyObject);\n    }\n\n    // If typename was not passed in, infer it. Note that typename is\n    // always passed in for tricky-to-infer cases such as \"Query\" for\n    // ROOT_QUERY.\n    const typename: string | undefined =\n      (dataId && policies.rootTypenamesById[dataId]) ||\n      getTypenameFromResult(result, selectionSet, context.fragmentMap) ||\n      (dataId && context.store.get(dataId, \"__typename\") as string);\n\n    if (\"string\" === typeof typename) {\n      incomingFields.__typename = typename;\n    }\n\n    const workSet = new Set(selectionSet.selections);\n\n    workSet.forEach(selection => {\n      if (!shouldInclude(selection, context.variables)) return;\n\n      if (isField(selection)) {\n        const resultFieldKey = resultKeyNameFromField(selection);\n        const value = result[resultFieldKey];\n\n        if (typeof value !== 'undefined') {\n          const storeFieldName = policies.getStoreFieldName({\n            typename,\n            fieldName: selection.name.value,\n            field: selection,\n            variables: context.variables,\n          });\n\n          const childTree = getChildMergeTree(mergeTree, storeFieldName);\n\n          let incomingValue =\n            this.processFieldValue(value, selection, context, childTree);\n\n          const childTypename = selection.selectionSet\n            && context.store.getFieldValue<string>(incomingValue as StoreObject, \"__typename\")\n            || void 0;\n\n          const merge = policies.getMergeFunction(\n            typename,\n            selection.name.value,\n            childTypename,\n          );\n\n          if (merge) {\n            childTree.info = {\n              // TODO Check compatibility against any existing\n              // childTree.field?\n              field: selection,\n              typename,\n              merge,\n            };\n          } else {\n            maybeRecycleChildMergeTree(mergeTree, storeFieldName);\n          }\n\n          incomingFields = context.merge(incomingFields, {\n            [storeFieldName]: incomingValue,\n          });\n\n        } else if (\n          policies.usingPossibleTypes &&\n          !hasDirectives([\"defer\", \"client\"], selection)\n        ) {\n          throw new InvariantError(\n            `Missing field '${resultFieldKey}' in ${JSON.stringify(\n              result,\n              null,\n              2,\n            ).substring(0, 100)}`,\n          );\n        }\n      } else {\n        // This is not a field, so it must be a fragment, either inline or named\n        const fragment = getFragmentFromSelection(\n          selection,\n          context.fragmentMap,\n        );\n\n        if (fragment &&\n            // By passing result and context.variables, we enable\n            // policies.fragmentMatches to bend the rules when typename is\n            // not a known subtype of the fragment type condition, but the\n            // result object contains all the keys requested by the\n            // fragment, which strongly suggests the fragment probably\n            // matched. This fuzzy matching behavior must be enabled by\n            // including a regular expression string (such as \".*\" or\n            // \"Prefix.*\" or \".*Suffix\") in the possibleTypes array for\n            // specific supertypes; otherwise, all matching remains exact.\n            // Fuzzy matches are remembered by the Policies object and\n            // later used when reading from the cache. Since there is no\n            // incoming result object to check when reading, reading does\n            // not involve the same fuzzy inference, so the StoreReader\n            // class calls policies.fragmentMatches without passing result\n            // or context.variables. The flexibility of fuzzy matching\n            // allows existing clients to accommodate previously unknown\n            // __typename strings produced by server/schema changes, which\n            // would otherwise be breaking changes.\n            policies.fragmentMatches(fragment, typename, result, context.variables)) {\n          fragment.selectionSet.selections.forEach(workSet.add, workSet);\n        }\n      }\n    });\n\n    if (\"string\" === typeof dataId) {\n      const entityRef = makeReference(dataId);\n\n      if (mergeTree.map.size) {\n        incomingFields = this.applyMerges(mergeTree, entityRef, incomingFields, context);\n      }\n\n      if (process.env.NODE_ENV !== \"production\") {\n        const hasSelectionSet = (storeFieldName: string) =>\n          fieldsWithSelectionSets.has(fieldNameFromStoreName(storeFieldName));\n        const fieldsWithSelectionSets = new Set<string>();\n        workSet.forEach(selection => {\n          if (isField(selection) && selection.selectionSet) {\n            fieldsWithSelectionSets.add(selection.name.value);\n          }\n        });\n\n        const hasMergeFunction = (storeFieldName: string) => {\n          const childTree = mergeTree.map.get(storeFieldName);\n          return Boolean(childTree && childTree.info && childTree.info.merge);\n        };\n\n        Object.keys(incomingFields).forEach(storeFieldName => {\n          // If a merge function was defined for this field, trust that it\n          // did the right thing about (not) clobbering data. If the field\n          // has no selection set, it's a scalar field, so it doesn't need\n          // a merge function (even if it's an object, like JSON data).\n          if (hasSelectionSet(storeFieldName) &&\n              !hasMergeFunction(storeFieldName)) {\n            warnAboutDataLoss(\n              entityRef,\n              incomingFields,\n              storeFieldName,\n              context.store,\n            );\n          }\n        });\n      }\n\n      context.store.merge(dataId, incomingFields);\n\n      return entityRef;\n    }\n\n    return incomingFields;\n  }\n\n  private processFieldValue(\n    value: any,\n    field: FieldNode,\n    context: WriteContext,\n    mergeTree: MergeTree,\n  ): StoreValue {\n    if (!field.selectionSet || value === null) {\n      // In development, we need to clone scalar values so that they can be\n      // safely frozen with maybeDeepFreeze in readFromStore.ts. In production,\n      // it's cheaper to store the scalar values directly in the cache.\n      return process.env.NODE_ENV === 'production' ? value : cloneDeep(value);\n    }\n\n    if (Array.isArray(value)) {\n      return value.map((item, i) => {\n        const value = this.processFieldValue(\n          item, field, context, getChildMergeTree(mergeTree, i));\n        maybeRecycleChildMergeTree(mergeTree, i);\n        return value;\n      });\n    }\n\n    return this.processSelectionSet({\n      result: value,\n      selectionSet: field.selectionSet,\n      context,\n      mergeTree,\n    });\n  }\n\n  private applyMerges<T extends StoreValue>(\n    mergeTree: MergeTree,\n    existing: StoreValue,\n    incoming: T,\n    context: ReadMergeModifyContext,\n    getStorageArgs?: Parameters<EntityStore[\"getStorage\"]>,\n  ): T {\n    if (mergeTree.map.size && !isReference(incoming)) {\n      const e: StoreObject | Reference | undefined = (\n        // Items in the same position in different arrays are not\n        // necessarily related to each other, so when incoming is an array\n        // we process its elements as if there was no existing data.\n        !Array.isArray(incoming) &&\n        // Likewise, existing must be either a Reference or a StoreObject\n        // in order for its fields to be safe to merge with the fields of\n        // the incoming object.\n        (isReference(existing) || storeValueIsStoreObject(existing))\n      ) ? existing : void 0;\n\n      // This narrowing is implied by mergeTree.map.size > 0 and\n      // !isReference(incoming), though TypeScript understandably cannot\n      // hope to infer this type.\n      const i = incoming as StoreObject | StoreValue[];\n\n      // The options.storage objects provided to read and merge functions\n      // are derived from the identity of the parent object plus a\n      // sequence of storeFieldName strings/numbers identifying the nested\n      // field name path of each field value to be merged.\n      if (e && !getStorageArgs) {\n        getStorageArgs = [isReference(e) ? e.__ref : e];\n      }\n\n      // It's possible that applying merge functions to this subtree will\n      // not change the incoming data, so this variable tracks the fields\n      // that did change, so we can create a new incoming object when (and\n      // only when) at least one incoming field has changed. We use a Map\n      // to preserve the type of numeric keys.\n      let changedFields: Map<string | number, StoreValue> | undefined;\n\n      const getValue = (\n        from: typeof e | typeof i,\n        name: string | number,\n      ): StoreValue => {\n        return Array.isArray(from)\n          ? (typeof name === \"number\" ? from[name] : void 0)\n          : context.store.getFieldValue(from, String(name))\n      };\n\n      mergeTree.map.forEach((childTree, storeFieldName) => {\n        if (getStorageArgs) {\n          getStorageArgs.push(storeFieldName);\n        }\n        const eVal = getValue(e, storeFieldName);\n        const iVal = getValue(i, storeFieldName);\n        const aVal = this.applyMerges(\n          childTree,\n          eVal,\n          iVal,\n          context,\n          getStorageArgs,\n        );\n        if (aVal !== iVal) {\n          changedFields = changedFields || new Map;\n          changedFields.set(storeFieldName, aVal);\n        }\n        if (getStorageArgs) {\n          invariant(getStorageArgs.pop() === storeFieldName);\n        }\n      });\n\n      if (changedFields) {\n        // Shallow clone i so we can add changed fields to it.\n        incoming = (Array.isArray(i) ? i.slice(0) : { ...i }) as T;\n        changedFields.forEach((value, name) => {\n          (incoming as any)[name] = value;\n        });\n      }\n    }\n\n    if (mergeTree.info) {\n      return this.cache.policies.runMergeFunction(\n        existing,\n        incoming,\n        mergeTree.info,\n        context,\n        getStorageArgs && context.store.getStorage(...getStorageArgs),\n      );\n    }\n\n    return incoming;\n  }\n}\n\nconst emptyMergeTreePool: MergeTree[] = [];\n\nfunction getChildMergeTree(\n  { map }: MergeTree,\n  name: string | number,\n): MergeTree {\n  if (!map.has(name)) {\n    map.set(name, emptyMergeTreePool.pop() || { map: new Map });\n  }\n  return map.get(name)!;\n}\n\nfunction maybeRecycleChildMergeTree(\n  { map }: MergeTree,\n  name: string | number,\n) {\n  const childTree = map.get(name);\n  if (childTree &&\n      !childTree.info &&\n      !childTree.map.size) {\n    emptyMergeTreePool.push(childTree);\n    map.delete(name);\n  }\n}\n\nconst warnings = new Set<string>();\n\n// Note that this function is unused in production, and thus should be\n// pruned by any well-configured minifier.\nfunction warnAboutDataLoss(\n  existingRef: Reference,\n  incomingObj: StoreObject,\n  storeFieldName: string,\n  store: NormalizedCache,\n) {\n  const getChild = (objOrRef: StoreObject | Reference): StoreObject | false => {\n    const child = store.getFieldValue<StoreObject>(objOrRef, storeFieldName);\n    return typeof child === \"object\" && child;\n  };\n\n  const existing = getChild(existingRef);\n  if (!existing) return;\n\n  const incoming = getChild(incomingObj);\n  if (!incoming) return;\n\n  // It's always safe to replace a reference, since it refers to data\n  // safely stored elsewhere.\n  if (isReference(existing)) return;\n\n  // If the values are structurally equivalent, we do not need to worry\n  // about incoming replacing existing.\n  if (equal(existing, incoming)) return;\n\n  // If we're replacing every key of the existing object, then the\n  // existing data would be overwritten even if the objects were\n  // normalized, so warning would not be helpful here.\n  if (Object.keys(existing).every(\n    key => store.getFieldValue(incoming, key) !== void 0)) {\n    return;\n  }\n\n  const parentType =\n    store.getFieldValue<string>(existingRef, \"__typename\") ||\n    store.getFieldValue<string>(incomingObj, \"__typename\");\n  const fieldName = fieldNameFromStoreName(storeFieldName);\n  const typeDotName = `${parentType}.${fieldName}`;\n  // Avoid warning more than once for the same type and field name.\n  if (warnings.has(typeDotName)) return;\n  warnings.add(typeDotName);\n\n  const childTypenames: string[] = [];\n  // Arrays do not have __typename fields, and always need a custom merge\n  // function, even if their elements are normalized entities.\n  if (!Array.isArray(existing) &&\n      !Array.isArray(incoming)) {\n    [existing, incoming].forEach(child => {\n      const typename = store.getFieldValue(child, \"__typename\");\n      if (typeof typename === \"string\" &&\n          !childTypenames.includes(typename)) {\n        childTypenames.push(typename);\n      }\n    });\n  }\n\n  invariant.warn(\n`Cache data may be lost when replacing the ${fieldName} field of a ${parentType} object.\n\nTo address this problem (which is not a bug in Apollo Client), ${\n  childTypenames.length\n    ? \"either ensure all objects of type \" +\n        childTypenames.join(\" and \") + \" have an ID or a custom merge function, or \"\n    : \"\"\n}define a custom merge function for the ${\n  typeDotName\n} field, so InMemoryCache can safely merge these objects:\n\n  existing: ${JSON.stringify(existing).slice(0, 1000)}\n  incoming: ${JSON.stringify(incoming).slice(0, 1000)}\n\nFor more information about these options, please refer to the documentation:\n\n  * Ensuring entity objects have IDs: https://go.apollo.dev/c/generating-unique-identifiers\n  * Defining custom merge functions: https://go.apollo.dev/c/merging-non-normalized-objects\n`);\n}\n"]}