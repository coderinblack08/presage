{"version":3,"file":"Observable.js","sourceRoot":"","sources":["../../../src/utilities/observables/Observable.ts"],"names":[],"mappings":"AAAA,OAAO,UAAU,MAAM,gBAAgB,CAAC;AAIxC,OAAO,mBAAmB,CAAC;AASnB,IAAA,SAAS,GAAK,UAAU,UAAf,CAAgB;AACjC,IAAM,aAAa,GAAG,cAAwC,CAAC;AAC/D,IAAI,CAAC,SAAS,CAAC,aAAa,CAAC,EAAE;IAC7B,SAAS,CAAC,aAAa,CAAC,GAAG,cAAc,OAAO,IAAI,CAAC,CAAC,CAAC,CAAC;CACzD;AAED,OAAO,EAAE,UAAU,EAAE,CAAC","sourcesContent":["import Observable from 'zen-observable';\n\n// This simplified polyfill attempts to follow the ECMAScript Observable\n// proposal (https://github.com/zenparsing/es-observable)\nimport 'symbol-observable';\n\nexport type ObservableSubscription = ZenObservable.Subscription;\nexport type Observer<T> = ZenObservable.Observer<T>;\nexport type Subscriber<T> = ZenObservable.Subscriber<T>;\n\n// The zen-observable package defines Observable.prototype[Symbol.observable]\n// when Symbol is supported, but RxJS interop depends on also setting this fake\n// '@@observable' string as a polyfill for Symbol.observable.\nconst { prototype } = Observable;\nconst fakeObsSymbol = '@@observable' as keyof typeof prototype;\nif (!prototype[fakeObsSymbol]) {\n  prototype[fakeObsSymbol] = function () { return this; };\n}\n\nexport { Observable };\n"]}