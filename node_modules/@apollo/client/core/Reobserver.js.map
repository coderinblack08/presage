{"version":3,"file":"Reobserver.js","sourceRoot":"","sources":["../../src/core/Reobserver.ts"],"names":[],"mappings":"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","sourcesContent":["import { WatchQueryOptions } from './watchQueryOptions';\nimport { NetworkStatus } from './networkStatus';\nimport { ApolloQueryResult } from './types';\nimport { Observer, Concast, compact } from '../utilities';\nimport { invariant } from 'ts-invariant';\n\n// Given that QueryManager#fetchQueryObservable returns only a single\n// query's worth of results, other code must be responsible for repeatedly\n// calling fetchQueryObservable, while ensuring that the ObservableQuery\n// consuming those results remains subscribed to the concatenation of all\n// the observables returned by fetchQueryObservable. That responsibility\n// falls to this Reobserver class. As a bonus, the Reobserver class is\n// perfectly poised to handle polling logic, since polling is essentially\n// repeated reobservation. In principle, this code could have remained in\n// the ObservableQuery class, but I felt it would be easier to explain and\n// understand reobservation if it was confined to a separate class.\nexport class Reobserver<TData, TVars> {\n  constructor(\n    private observer: Observer<ApolloQueryResult<TData>>,\n    private options: WatchQueryOptions<TVars, TData>,\n    // Almost certainly just a wrapper function around\n    // QueryManager#fetchQueryObservable, but this small dose of\n    // indirection means the Reobserver doesn't have to know/assume\n    // anything about the QueryManager class.\n    private fetch: (\n      options: WatchQueryOptions<TVars, TData>,\n      newNetworkStatus?: NetworkStatus,\n    ) => Concast<ApolloQueryResult<TData>>,\n    // If we're polling, there may be times when we should avoid fetching,\n    // such as when the query is already in flight, or polling has been\n    // completely disabled for server-side rendering. Passing false for\n    // this parameter disables polling completely, and passing a boolean\n    // function allows determining fetch safety dynamically.\n    private shouldFetch: false | (() => boolean),\n  ) {}\n\n  private concast?: Concast<ApolloQueryResult<TData>>;\n\n  public reobserve(\n    newOptions?: Partial<WatchQueryOptions<TVars, TData>>,\n    newNetworkStatus?: NetworkStatus,\n  ): Promise<ApolloQueryResult<TData>> {\n    if (newOptions) {\n      this.updateOptions(newOptions);\n    } else {\n      // When we call this.updateOptions(newOptions) in the branch above,\n      // it takes care of calling this.updatePolling(). In this branch, we\n      // still need to update polling, even if there were no newOptions.\n      this.updatePolling();\n    }\n\n    const concast = this.fetch(this.options, newNetworkStatus);\n\n    if (this.concast) {\n      // We use the {add,remove}Observer methods directly to avoid\n      // wrapping observer with an unnecessary SubscriptionObserver\n      // object, in part so that we can remove it here without triggering\n      // any unsubscriptions, because we just want to ignore the old\n      // observable, not prematurely shut it down, since other consumers\n      // may be awaiting this.concast.promise.\n      this.concast.removeObserver(this.observer, true);\n    }\n\n    concast.addObserver(this.observer);\n\n    return (this.concast = concast).promise;\n  }\n\n  public updateOptions(newOptions: Partial<WatchQueryOptions<TVars, TData>>) {\n    Object.assign(this.options, compact(newOptions));\n    this.updatePolling();\n    return this;\n  }\n\n  public stop() {\n    if (this.concast) {\n      this.concast.removeObserver(this.observer);\n      delete this.concast;\n    }\n\n    if (this.pollingInfo) {\n      clearTimeout(this.pollingInfo.timeout);\n      this.options.pollInterval = 0;\n      this.updatePolling();\n    }\n  }\n\n  private pollingInfo?: {\n    interval: number;\n    timeout: ReturnType<typeof setTimeout>;\n  };\n\n  // Turns polling on or off based on this.options.pollInterval.\n  private updatePolling() {\n    const {\n      pollingInfo,\n      options: {\n        pollInterval,\n      },\n    } = this;\n\n    if (!pollInterval) {\n      if (pollingInfo) {\n        clearTimeout(pollingInfo.timeout);\n        delete this.pollingInfo;\n      }\n      return;\n    }\n\n    if (pollingInfo &&\n        pollingInfo.interval === pollInterval) {\n      return;\n    }\n\n    invariant(\n      pollInterval,\n      'Attempted to start a polling query without a polling interval.',\n    );\n\n    // Go no further if polling is disabled.\n    if (this.shouldFetch === false) {\n      return;\n    }\n\n    const info = pollingInfo || (\n      this.pollingInfo = {} as Reobserver<TData, TVars>[\"pollingInfo\"]\n    )!;\n\n    info.interval = pollInterval;\n\n    const maybeFetch = () => {\n      if (this.pollingInfo) {\n        if (this.shouldFetch && this.shouldFetch()) {\n          this.reobserve({\n            fetchPolicy: \"network-only\",\n            nextFetchPolicy: this.options.fetchPolicy || \"cache-first\",\n          }, NetworkStatus.poll).then(poll, poll);\n        } else {\n          poll();\n        }\n      };\n    };\n\n    const poll = () => {\n      const info = this.pollingInfo;\n      if (info) {\n        clearTimeout(info.timeout);\n        info.timeout = setTimeout(maybeFetch, info.interval);\n      }\n    };\n\n    poll();\n  }\n}\n"]}