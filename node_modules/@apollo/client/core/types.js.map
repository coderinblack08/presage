{"version":3,"file":"types.js","sourceRoot":"","sources":["../../src/core/types.ts"],"names":[],"mappings":"","sourcesContent":["import { DocumentNode, GraphQLError } from 'graphql';\n\nimport { FetchResult } from '../link/core';\nimport { ApolloError } from '../errors';\nimport { QueryInfo } from './QueryInfo';\nimport { NetworkStatus } from './networkStatus';\nimport { Resolver } from './LocalState';\n\nexport { TypedDocumentNode } from '@graphql-typed-document-node/core';\n\nexport type QueryListener = (queryInfo: QueryInfo) => void;\n\nexport type OperationVariables = Record<string, any>;\n\nexport type PureQueryOptions = {\n  query: DocumentNode;\n  variables?: { [key: string]: any };\n  context?: any;\n};\n\nexport type ApolloQueryResult<T> = {\n  data: T;\n  errors?: ReadonlyArray<GraphQLError>;\n  error?: ApolloError;\n  loading: boolean;\n  networkStatus: NetworkStatus;\n  // If result.data was read from the cache with missing fields,\n  // result.partial will be true. Otherwise, result.partial will be falsy\n  // (usually because the property is absent from the result object).\n  partial?: boolean;\n};\n\n// This is part of the public API, people write these functions in `updateQueries`.\nexport type MutationQueryReducer<T> = (\n  previousResult: Record<string, any>,\n  options: {\n    mutationResult: FetchResult<T>;\n    queryName: string | undefined;\n    queryVariables: Record<string, any>;\n  },\n) => Record<string, any>;\n\nexport type MutationQueryReducersMap<T = { [key: string]: any }> = {\n  [queryName: string]: MutationQueryReducer<T>;\n};\n\nexport interface Resolvers {\n  [key: string]: {\n    [ field: string ]: Resolver;\n  };\n}\n"]}